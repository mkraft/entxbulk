// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"
	"strings"
)

type UserBulkUpdate struct {
	ID        int
	HubspotId *string
}

func (c *UserClient) BulkUpdate(ctx context.Context, updates []UserBulkUpdate) error {
	if len(updates) == 0 {
		return nil
	}

	// Find all fields that are non-nil in any update
	fields := []string{}
	fieldMap := map[string]bool{}
	for _, u := range updates {
		if u.HubspotId != nil {
			if !fieldMap["hubspot_id"] {
				fields = append(fields, "hubspot_id")
				fieldMap["hubspot_id"] = true
			}
		}
	}
	if len(fields) == 0 {
		return nil // nothing to update
	}

	var (
		params []interface{}
		values []string
	)

	paramIdx := 1
	for _, u := range updates {
		placeholders := make([]string, 0, len(fields)+1)
		// id first
		placeholders = append(placeholders, fmt.Sprintf("$%d::bigint", paramIdx))
		params = append(params, u.ID)
		paramIdx++
		// then each field in order
		if u.HubspotId != nil {
			placeholders = append(placeholders, fmt.Sprintf("$%d", paramIdx))
			params = append(params, *u.HubspotId)
			paramIdx++
		}
		values = append(values, fmt.Sprintf("(%s)", strings.Join(placeholders, ", ")))
	}

	// SET clause
	setClause := make([]string, len(fields))
	for i, f := range fields {
		setClause[i] = fmt.Sprintf("%s = data.%s", f, f)
	}

	// AS data(...) column list
	columns := append([]string{"id"}, fields...)

	query := fmt.Sprintf(`
UPDATE users
SET %s
FROM (VALUES %%s) AS data(%s)
WHERE users.id = data.id;
`, strings.Join(setClause, ", "), strings.Join(columns, ", "))
	query = fmt.Sprintf(query, strings.Join(values, ", "))
	err := c.driver.Exec(ctx, query, params, nil)
	if err != nil {
		log.Printf("Bulk update failed: %v", err)
	}
	return err
}
